# zoom_client.py
import time
import re
from datetime import datetime, timedelta
import requests
import pytz
import dateparser


class ZoomClient:
    TOKEN_URL = "https://zoom.us/oauth/token"
    API_BASE = "https://api.zoom.us/v2"

    def __init__(self, account_id: str, client_id: str, client_secret: str,
                 host_email: str, tz: str = "Europe/Moscow"):
        if not all([account_id, client_id, client_secret, host_email]):
            raise ValueError("ZoomClient: –Ω–µ –∑–∞–¥–∞–Ω—ã ACCOUNT_ID/CLIENT_ID/CLIENT_SECRET/HOST_EMAIL")
        self.account_id = account_id
        self.client_id = client_id
        self.client_secret = client_secret
        self.host_email = host_email
        self.tz = tz
        self._access_token = None
        self._exp_ts = 0  # unix-–≤—Ä–µ–º—è –∏—Å—Ç–µ—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
# ====== –ë–†–£–¢-–§–û–†–° –ü–û –ú–ò–ù–£–¢–ê–ú –°–£–¢–û–ö ======

# –ø—Ä–æ–±–µ–ª—ã: –æ–±—ã—á–Ω—ã–π, NBSP, —É–∑–∫–∏–π, —Ç–æ–Ω–∫–∏–π
_SPACE_CLASS = r"[\s\u00A0\u202F\u2009]"

def _build_time_patterns():
    """
    –ì–æ—Ç–æ–≤–∏–º —Å–ø–∏—Å–æ–∫ –∫–æ—Ä—Ç–µ–∂–µ–π (compiled_regex, (hour, minute)).
    –ü–æ–∫—Ä—ã–≤–∞–µ–º —Ñ–æ—Ä–º–∞—Ç—ã: HH:MM, H:MM, HH-MM, H-MM, HH.MM, H.MM, HH MM, H MM.
    """
    pats = []
    for h in range(24):
        hh = f"{h:02d}"
        h1 = str(h)               # –±–µ–∑ –≤–µ–¥—É—â–µ–≥–æ –Ω—É–ª—è
        for m in range(60):
            mm = f"{m:02d}"

            fmt_strs = [
                rf"\b{hh}:{mm}\b",
                rf"\b{h1}:{mm}\b" if h1 != hh else None,

                rf"\b{hh}-{mm}\b",
                rf"\b{h1}-{mm}\b" if h1 != hh else None,

                rf"\b{hh}\.{mm}\b",
                rf"\b{h1}\.{mm}\b" if h1 != hh else None,

                rf"\b{hh}{_SPACE_CLASS}+{mm}\b",
                rf"\b{h1}{_SPACE_CLASS}+{mm}\b" if h1 != hh else None,
            ]
            for s in fmt_strs:
                if s is None:
                    continue
                pats.append((re.compile(s, re.IGNORECASE), (h, m)))
    return pats

# –ü—Ä–µ–¥–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ
_TIME_PATTERNS = _build_time_patterns()
    
    # ---------- –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ ----------
    def _get_access_token(self) -> str:
        if self._access_token and time.time() < self._exp_ts - 60:
            return self._access_token

        r = requests.post(
            self.TOKEN_URL,
            params={"grant_type": "account_credentials", "account_id": self.account_id},
            auth=(self.client_id, self.client_secret),
            timeout=15,
        )
        r.raise_for_status()
        data = r.json()
        self._access_token = data["access_token"]
        self._exp_ts = time.time() + int(data.get("expires_in", 3600))
        return self._access_token

    def _headers(self):
        return {
            "Authorization": f"Bearer {self._get_access_token()}",
            "Content-Type": "application/json",
        }

    def _to_utc_iso(self, when_dt: datetime) -> str:
        tz = pytz.timezone(self.tz)
        local = tz.localize(when_dt) if when_dt.tzinfo is None else when_dt.astimezone(tz)
        return local.astimezone(pytz.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    # ---------- API ----------
    def create_meeting(self, topic: str, when_dt: datetime, duration_min: int = 60) -> dict:
        payload = {
            "topic": topic or "–í—Å—Ç—Ä–µ—á–∞",
            "type": 2,
            "start_time": self._to_utc_iso(when_dt),
            "duration": duration_min,
            "timezone": self.tz,
            "settings": {"waiting_room": True},
        }
        r = requests.post(
            f"{self.API_BASE}/users/{self.host_email}/meetings",
            headers=self._headers(),
            json=payload,
            timeout=20,
        )
        r.raise_for_status()
        return r.json()

    def list_meetings(self, status: str = "upcoming", page_size: int = 20) -> list[dict]:
        r = requests.get(
            f"{self.API_BASE}/users/{self.host_email}/meetings",
            headers=self._headers(),
            params={"type": status, "page_size": page_size},
            timeout=20,
        )
        r.raise_for_status()
        return r.json().get("meetings", [])

    def delete_meeting(self, meeting_id: str) -> bool:
        r = requests.delete(
            f"{self.API_BASE}/meetings/{meeting_id}",
            headers=self._headers(),
            timeout=20,
        )
        if r.status_code not in (200, 204):
            r.raise_for_status()
        return True


# ----- —É—Ç–∏–ª–∏—Ç—ã –¥–ª—è —á–∞—Ç–∞ -----

def _fmt_meetings(items: list[dict], tz_name: str) -> str:
    if not items:
        return "üóìÔ∏è –í—Å—Ç—Ä–µ—á –Ω–µ—Ç."
    tz = pytz.timezone(tz_name)
    lines = []
    for i, m in enumerate(items, 1):
        start = m.get("start_time")
        when = "‚Äî"
        if start:
            dt = datetime.fromisoformat(start.replace("Z", "+00:00")).astimezone(tz)
            when = dt.strftime("%d.%m.%Y %H:%M")
        lines.append(f"{i}. {m.get('topic') or '–ë–µ–∑ —Ç–µ–º—ã'} ‚Ä¢ ID: {m.get('id')} ‚Ä¢ {when}")
    return "üóìÔ∏è –ë–ª–∏–∂–∞–π—à–∏–µ –≤—Å—Ç—Ä–µ—á–∏:\n" + "\n".join(lines)


# --- –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏ ---

MONTHS_RU = {
    "—è–Ω–≤–∞—Ä": 1, "—Ñ–µ–≤—Ä–∞–ª": 2, "–º–∞—Ä—Ç": 3, "–∞–ø—Ä–µ–ª": 4, "–º–∞": 5,
    "–∏—é–Ω": 6, "–∏—é–ª": 7, "–∞–≤–≥—É—Å—Ç": 8, "—Å–µ–Ω—Ç—è–±—Ä": 9, "–æ–∫—Ç—è–±—Ä": 10, "–Ω–æ—è–±—Ä": 11, "–¥–µ–∫–∞–±—Ä": 12
}

def _strip_trailing_timestamp(text: str) -> str:
    """
    –°—Ä–µ–∑–∞–µ–º —Ö–≤–æ—Å—Ç '15:12' / '15 12' / '15-12' –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —ç—Ç–æ –≤—Ç–æ—Ä–æ–µ (–∏–ª–∏ –¥–∞–ª—å—à–µ) –≤—Ä–µ–º—è
    –≤ —Å—Ç—Ä–æ–∫–µ –∏ —Å—Ç–æ–∏—Ç –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ. –ï—Å–ª–∏ –≤—Ä–µ–º—è –æ–¥–Ω–æ ‚Äî –Ω–µ —Ç—Ä–æ–≥–∞–µ–º.
    """
    if not text:
        return text
    pattern = r"\b\d{1,2}[:\.\- ]\d{2}\b"
    matches = list(re.finditer(pattern, text))
    if len(matches) >= 2 and re.search(pattern + r"\s*$", text):
        last = matches[-1]
        return text[:last.start()].rstrip()
    return text



def _normalize_time_tokens(s: str) -> str:
    # 1) –ø—Ä–∏–≤–µ—Å—Ç–∏ ¬´–Ω–µ–≤–∏–¥–∏–º—ã–µ¬ª –ø—Ä–æ–±–µ–ª—ã –∫ –æ–±—ã—á–Ω–æ–º—É
    s = (s or "").replace("\u202f", " ").replace("\u00a0", " ").replace("\u2009", " ")

    # 2) 17 00 / 17-00 / 17.00 / 17:00 ‚Üí 17:00 (–æ—Å—Ç–∞–≤–ª—è–µ–º : –∫–∞–∫ —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å)
    s = re.sub(r"\b(\d{1,2})[\s\.\-:](\d{2})\b", r"\1:\2", s)

    # 3) 14—á ‚Üí 14:00
    s = re.sub(r"\b(\d{1,2})\s*—á\b", r"\1:00", s)

    # 4) "–≤ 14" ‚Üí "–≤ 14:00" (–Ω–µ —Ç—Ä–æ–≥–∞–µ–º "–≤ 14:30")
    s = re.sub(r"\b–≤\s+(\d{1,2})(?!:)", r"–≤ \1:00", s)

    return s


def _extract_topic(text: str) -> str | None:
    m = re.search(r"[¬´\"']([^\"'¬ª]{3,120})[\"'¬ª]", text)
    if m:
        return m.group(1).strip()
    m = re.search(r"(?:—Ç–µ–º–∞|–Ω–∞ —Ç–µ–º—É|–æ —Ç–µ–º–µ)\s*[:\-]?\s*(.+)$", text, flags=re.IGNORECASE)
    if m:
        return m.group(2).strip()
    return None

def _parse_explicit_date(text: str, base: datetime) -> datetime | None:
    t = text.lower()

    # 1) dd.mm(.yyyy)?
    m = re.search(r"\b(\d{1,2})\.(\d{1,2})(?:\.(\d{4}))?\b", t)
    if m:
        d, mo, y = int(m.group(1)), int(m.group(2)), int(m.group(3) or base.year)
        try:
            return base.tzinfo.localize(datetime(y, mo, d)) if base.tzinfo else datetime(y, mo, d)
        except ValueError:
            return None

    # 2) dd <–º–µ—Å—è—Ü-—Å–ª–æ–≤–æ–º> (yyyy)?
    m = re.search(r"\b(\d{1,2})\s+([–∞-—è—ë]+)(?:\s+(\d{4}))?\b", t)
    if m:
        d = int(m.group(1))
        mon_word = m.group(2)
        y = int(m.group(3) or base.year)
        mon = None
        for stem, num in MONTHS_RU.items():
            if mon_word.startswith(stem):
                mon = num
                break
        if mon:
            try:
                return base.tzinfo.localize(datetime(y, mon, d)) if base.tzinfo else datetime(y, mon, d)
            except ValueError:
                return None

    # 3) –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞
    if "–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞" in t:
        return (base + timedelta(days=2)).replace(hour=0, minute=0, second=0, microsecond=0)
    if "–∑–∞–≤—Ç—Ä–∞" in t:
        return (base + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    if "—Å–µ–≥–æ–¥–Ω—è" in t:
        return base.replace(hour=0, minute=0, second=0, microsecond=0)

    return None

def _extract_time(text: str) -> tuple[int, int] | None:
    """
    –ë—Ä—É—Ç-—Ñ–æ—Ä—Å: –∏—â–µ–º –ª—é–±—É—é –∏–∑ 1440 –º–∏–Ω—É—Ç —Å—É—Ç–æ–∫ –≤ —Ç–∏–ø–æ–≤—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö.
    –í–æ–∑–≤—Ä–∞—â–∞–µ–º (—á–∞—Å—ã, –º–∏–Ω—É—Ç—ã) –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏.
    """
    if not text:
        return None

    # –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º ¬´–Ω–µ–≤–∏–¥–∏–º—ã–µ¬ª –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
    s = (text.replace("\u202f", " ")
             .replace("\u00a0", " ")
             .replace("\u2009", " "))

    for rx, (h, m) in _TIME_PATTERNS:
        if rx.search(s):
            return h, m
    return None





def _parse_when_ru(text: str, tz_name: str) -> datetime | None:
    """
    –ü–æ–ª–Ω–æ—Å—Ç—å—é –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –ë–ï–ó dateparser.
    –ü—Ä–∞–≤–∏–ª–∞:
      - –µ—Å—Ç—å –¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è ‚Üí —Å–∫–ª–µ–∏–≤–∞–µ–º
      - –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –¥–∞—Ç–∞ ‚Üí 10:00
      - –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –≤—Ä–µ–º—è ‚Üí —Å–µ–≥–æ–¥–Ω—è –≤ —ç—Ç–æ –≤—Ä–µ–º—è; –µ—Å–ª–∏ —É–∂–µ –ø—Ä–æ—à–ª–æ ‚Äî –∑–∞–≤—Ç—Ä–∞
    """
    s_orig = text or ""
    s = _strip_trailing_timestamp(s_orig)
    s = _normalize_time_tokens(s)  # '16 50' ‚Üí '16:50', '14—á' ‚Üí '14:00'
    s_low = s.lower()

    tz = pytz.timezone(tz_name)
    now = datetime.now(tz)

    # --- –î–∞—Ç–∞ ---
    day = None
    # –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ
    if "–ø–æ—Å–ª–µ–∑–∞–≤—Ç—Ä–∞" in s_low:
        day = (now + timedelta(days=2)).replace(hour=0, minute=0, second=0, microsecond=0)
    elif "–∑–∞–≤—Ç—Ä–∞" in s_low:
        day = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    elif "—Å–µ–≥–æ–¥–Ω—è" in s_low:
        day = now.replace(hour=0, minute=0, second=0, microsecond=0)

    # dd.mm(.yyyy)?
    if day is None:
        m = re.search(r"\b(\d{1,2})\.(\d{1,2})(?:\.(\d{4}))?\b", s_low)
        if m:
            d, mo, y = int(m.group(1)), int(m.group(2)), int(m.group(3) or now.year)
            try:
                day = tz.localize(datetime(y, mo, d))
            except ValueError:
                day = None

    # dd <–º–µ—Å—è—Ü>( yyyy)?
    if day is None:
        m = re.search(r"\b(\d{1,2})\s+([–∞-—è—ë]+)(?:\s+(\d{4}))?\b", s_low)
        if m:
            d = int(m.group(1))
            mon_word = m.group(2)
            y = int(m.group(3) or now.year)
            mon = None
            for stem, num in MONTHS_RU.items():
                if mon_word.startswith(stem):
                    mon = num
                    break
            if mon:
                try:
                    day = tz.localize(datetime(y, mon, d))
                except ValueError:
                    day = None

    # --- –í—Ä–µ–º—è ---
    tm = _extract_time(s_low)  # (—á–∞—Å, –º–∏–Ω)

    # --- –ö–æ–º–±–∏–Ω–∞—Ü–∏—è ---
    if day and tm:
        dt = day.replace(hour=tm[0], minute=tm[1])
        # –µ—Å–ª–∏ –¥–∞—Ç–∞ –±—ã–ª–∞ 'dd.mm' (–±–µ–∑ –≥–æ–¥–∞) –∏ —É–∂–µ –ø—Ä–æ—à–ª–∞ ‚Äî –ø–µ—Ä–µ–Ω–µ—Å—ë–º –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –≥–æ–¥
        if dt < now and re.search(r"\b\d{1,2}\.\d{1,2}\b", s_low) and not re.search(r"\b\d{1,2}\.\d{1,2}\.\d{4}\b", s_low):
            try:
                dt = dt.replace(year=dt.year + 1)
            except ValueError:
                pass
        return dt

    if day and not tm:
        return day.replace(hour=10, minute=0)

    if not day and tm:
        dt = now.replace(hour=tm[0], minute=tm[1], second=0, microsecond=0)
        if dt <= now:
            dt = dt + timedelta(days=1)
        return dt

    # –Ω–∏—á–µ–≥–æ –Ω–µ —Ä–∞–∑–æ–±—Ä–∞–ª–∏
    return None



# ----- –∏–Ω—Ç–µ–Ω—Ç—ã -----

def handle_zoom_intents(zoom: ZoomClient, text: str) -> str | None:
    original_text = text or ""
    t = (original_text or "").lower().strip()

    # —Å–ø–∏—Å–æ–∫ –≤—Å—Ç—Ä–µ—á
    if re.search(r"\b(—Å–ø–∏—Å–æ–∫|–º–æ–∏|–ø–æ–∫–∞–∂–∏)\s+–≤—Å—Ç—Ä–µ—á", t) or "–≤—Å—Ç—Ä–µ—á–∏ zoom" in t or "–≤—Å—Ç—Ä–µ—á–∏ –∑—É–º" in t:
        items = zoom.list_meetings("upcoming", 20)
        return _fmt_meetings(items, zoom.tz)

    # —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤—Å—Ç—Ä–µ—á–∏
    if re.search(r"(–æ—Ç–º–µ–Ω–∏|—É–¥–∞–ª–∏)\s+–≤—Å–µ\s+–≤—Å—Ç—Ä–µ—á", t):
        items = zoom.list_meetings("upcoming", 50)
        if not items:
            return "üóëÔ∏è –ù–µ—Ç –≤—Å—Ç—Ä–µ—á –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è."
        for m in items:
            zoom.delete_meeting(m["id"])
        return f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {len(items)} –≤—Å—Ç—Ä–µ—á."

    # —É–¥–∞–ª–∏—Ç—å –ø–æ ID
    m = re.search(r"(–æ—Ç–º–µ–Ω–∏|—É–¥–∞–ª–∏)\s+–≤—Å—Ç—Ä–µ—á[–∞—É—ã–µ]?\s+(\d{6,})", t)
    if m:
        mid = m.group(2)
        zoom.delete_meeting(mid)
        return f"üóëÔ∏è –í—Å—Ç—Ä–µ—á–∞ **{mid}** –æ—Ç–º–µ–Ω–µ–Ω–∞."

    # —Å–æ–∑–¥–∞–Ω–∏–µ
    if re.search(r"\b(—Å–æ–∑–¥–∞–π|—Å–æ–∑–¥–∞—Ç—å|—Å–¥–µ–ª–∞–π|–∑–∞–ø–ª–∞–Ω–∏—Ä—É–π)\b.*\b–≤—Å—Ç—Ä–µ—á[–∞—É—ã–µ]?\b", t) \
       or (("–≤ –∑—É–º" in t or "–≤ zoom" in t) and "–≤—Å—Ç—Ä–µ—á" in t):
        when = _parse_when_ru(original_text, zoom.tz) or datetime.now(pytz.timezone(zoom.tz)).replace(minute=0, second=0, microsecond=0)
        topic = _extract_topic(original_text) or "–í—Å—Ç—Ä–µ—á–∞"

        try:
            data = zoom.create_meeting(topic, when, 60)
        except requests.HTTPError as e:
            # –≤–µ—Ä–Ω—ë–º –¥–µ—Ç–∞–ª—å–Ω–µ–π—à—É—é –æ—à–∏–±–∫—É Zoom, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ —Å –ø—Ä–∞–≤–∞–º–∏/–ø–æ—á—Ç–æ–π
            return f"‚ùå Zoom API: {e.response.status_code} {e.response.text}"

        when_str = when.astimezone(pytz.timezone(zoom.tz)).strftime("%d.%m.%Y %H:%M")
        pwd = f"\n–ü–∞—Ä–æ–ª—å: {data.get('password')}" if data.get('password') else ""
        return (
            f"‚úÖ –í—Å—Ç—Ä–µ—á–∞ ¬´{topic}¬ª —Å–æ–∑–¥–∞–Ω–∞ –Ω–∞ {when_str} ({zoom.tz}).\n"
            f"–°—Å—ã–ª–∫–∞: {data.get('join_url')}\nID: {data.get('id')}{pwd}"
        )

    return None
